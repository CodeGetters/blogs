---
title: 'Vue.js设计与实现'
date: 2023-02-22
categories:
- 前端
tags:
- Vue
- 面包屋
sidebar: false
isShowComments: true
---
[[toc]]

## 第一篇 框架设计概览

### 第一章 权衡的艺术

* 命令式和响应式

命令式：关注过程(JQuery)
响应式：关注结果(Vue)

Vue的内部实现是命令式，暴露给用户的是响应式

* 性能与可维护性的权衡

结论：声明式代码的性能不优于命令式代码的性能

A = 声明式代码更新性能损耗
A+B = 声明式代码更新性能损耗

A：直接修改性能消耗
B：差异性能消耗

Vue为什么选择声明式设计方案---->声明式代码可维护性更强

* 虚拟DOM性能

虚拟DOM的出现：最小化找出差异的性能 ---> 使得声明式代码无限接近命令式代码

使用innerHTML和虚拟DOM的性能比较？--- 纯JS层面操作比DOM操作快得多

innerHTML将字符串渲染出DOM树--->渲染页面
innerHTML创建页面的性能 = HTML字符串拼接的计算量 + innerHTML DOM 计算量

虚拟DOM创建页面：创建JS对象 ---> 递归地遍历DOM树并创建真实DOM

JS对象：真实DOM的描述

创建JS对象计算量 + 创建真实DOM计算量

创建页面性能：
|原生JS|虚拟DOM|innerHTML|
|---|---|---|
|纯JS运算|创建JS对象(VNode)|渲染HTML字符串|
|DOM运算|创建所有DOM元素|新建所有DOM元素|

如果说，它们在一个较大的数量级上，两个的差距是不会很大的

更新页面时性能差异：
innerHTML：重新构建全部HTML字符串(哪怕一个字符变化也会销毁所有旧元素再全部创建新的DOM元素)
虚拟DOM：创建新JS对象 + Diff(必要的DOM更新)

从上面可看出innerHTML的性能主要与模板大小有关(模板越大，性能消耗越大)，而虚拟DOM则主要与数据变化量有关(数据量越大，性能消耗越大)

| 原生JS  | 虚拟DOM | innerHTML |
|-------|-------|-----------|
| 心智负担大 | 心智负担小 | 心智负担中     |
| 可维护性差 | 可维护性强 |中等|
| 性能高   | 性能不错  | 性能差       |

* 运行时和编译时

Render()：将一个树形结构的数据对象递归地将数据渲染成DOM元素--->纯运行时框架

例如：
```js
const obj = {
    //标签名
    tag:"div",
    //可数组可文本
    children:[{
        tag:"span",children:"hello world"
    }]
}
```

Compiler()：将HTML字符串编译成树形结构的数据对象

让用户分别调用Compiler和Render----> 运行时 + 编译时 = Vue

运行时编译：代码运行时才开始编译会产生一定会的性能开销，故在构建时就执行Compiler将用户提供的内容编译好，等到运行时就无需编译

将HTML字符串编译为命令式代码：只需Compiler---->纯编译时框架(Svelte)

不支持任何运行时内容，用户的代码通过编译器后才能运行

### 第二章 框架设计的核心要素

### 第三章 Vue 的设计思路

## 第二篇 响应系统

### 第四章 响应系统的作用与实现

### 第五章 非原始值的响应式方案

### 第六章 原始值的响应式方案

## 渲染器
