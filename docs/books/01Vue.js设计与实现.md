---
title: 'Vue.js设计与实现'
date: 2023-02-22
categories:
- 前端
tags:
- Vue
- 面包屋
sidebar: true
isShowComments: true
---
[[toc]]

## 第一篇 框架设计概览

### 第一章 权衡的艺术

* 命令式和响应式

命令式：关注过程(JQuery)
响应式：关注结果(Vue)

Vue的内部实现是命令式，暴露给用户的是响应式

* 性能与可维护性的权衡

结论：声明式代码的性能不优于命令式代码的性能

A = 声明式代码更新性能损耗
A+B = 声明式代码更新性能损耗

A：直接修改性能消耗
B：差异性能消耗

Vue为什么选择声明式设计方案---->声明式代码可维护性更强

* 虚拟DOM性能

虚拟DOM的出现：最小化找出差异的性能 ---> 使得声明式代码无限接近命令式代码

使用innerHTML和虚拟DOM的性能比较？--- 纯JS层面操作比DOM操作快得多

innerHTML将字符串渲染出DOM树--->渲染页面
innerHTML创建页面的性能 = HTML字符串拼接的计算量 + innerHTML DOM 计算量

虚拟DOM创建页面：创建JS对象 ---> 递归地遍历DOM树并创建真实DOM

JS对象：真实DOM的描述

创建JS对象计算量 + 创建真实DOM计算量

创建页面性能：
|原生JS|虚拟DOM|innerHTML|
|---|---|---|
|纯JS运算|创建JS对象(VNode)|渲染HTML字符串|
|DOM运算|创建所有DOM元素|新建所有DOM元素|

如果说，它们在一个较大的数量级上，两个的差距是不会很大的

更新页面时性能差异：
innerHTML：重新构建全部HTML字符串(哪怕一个字符变化也会销毁所有旧元素再全部创建新的DOM元素)
虚拟DOM：创建新JS对象 + Diff(必要的DOM更新)

从上面可看出innerHTML的性能主要与模板大小有关(模板越大，性能消耗越大)，而虚拟DOM则主要与数据变化量有关(数据量越大，性能消耗越大)

| 原生JS  | 虚拟DOM | innerHTML |
|-------|-------|-----------|
| 心智负担大 | 心智负担小 | 心智负担中     |
| 可维护性差 | 可维护性强 |中等|
| 性能高   | 性能不错  | 性能差       |

* 运行时和编译时

Render()：将一个树形结构的数据对象递归地将数据渲染成DOM元素--->纯运行时框架

例如：
```js
const obj = {
    //标签名
    tag:"div",
    //可数组可文本
    children:[{
        tag:"span",children:"hello world"
    }]
}
```

Compiler()：将HTML字符串编译成树形结构的数据对象

让用户分别调用Compiler和Render----> 运行时 + 编译时 = Vue

运行时编译：代码运行时才开始编译会产生一定会的性能开销，故在构建时就执行Compiler将用户提供的内容编译好，等到运行时就无需编译

将HTML字符串编译为命令式代码：只需Compiler---->纯编译时框架(Svelte)

不支持任何运行时内容，用户的代码通过编译器后才能运行

### 第二章 框架设计的核心要素
* 提升用户开发体验

警告信息
控制台输出结果

* 控制框架代码体积

dead code：永远不会执行的代码

* 良好的Tree-Shaking

Tree-Shaking：消除永远不会被执行的代码

条件：模块必须是ESM(Tree-Shaking依赖ESM静态结构)

副作用：当调用函数的时候会对外部产生影响(修改全局变量)

```js

//告诉rollup函数不会产生副作用
/*#__PURE_*/
```

* 输出怎样的构建物

根据环境不同(开发或生产)输出产物
IIFE：立即调用的函数表达式(Immediately Invoked Function Expression)
Node中，资源模块格式为CommonJS

* 特性开关--->有效Tree-Shaking
* 错误处理
* 良好的TS类型支持

### 第三章 Vue 的设计思路
* 声明式描述UI

使用JS对象和模板描述UI有什么不同：JS对象描述UI更加灵活

组件的渲染函数：一个组件要渲染的内容是通过渲染函数来描述的，也就是Render()，
Vue会根据组件的Render()的返回值拿到虚拟DOM，然后就可以把组件的内容渲染出来

* 渲染器

渲染器作用：将虚拟DOM变成真实DOM并渲染到浏览器页面中

实现思路：创建元素----->为元素添加属性和事件---->处理children

* 组件的本质

组件：一组DOM元素的封装，这组DOM元素就是组件要渲染的内容

组件不一定必须是函数，也可以是对象！

* 模板工作原理

手写虚拟DOM(渲染函数)，和使用模板都属于声明式描述UI(Vue同时支持)

编译器作用：将模板编译为渲染函数并添加到`<script>`标签块的组件对象上

对组件来说，渲染的内容最终都通过渲染函数产生的

* Vue是各个模板组成的有机整体

组件的实现依赖渲染器，模版的编译依赖编译器

## 第二篇 响应系统

### 第四章 响应系统的作用与实现

* 响应式数据与副作用函数

副作用函数：会产生副作用的函数---除本函数之外的任何函数都可以读取或设置 body 的文本内容。也就是说，该函数的执行会直接或间接影响其它函数的执行

响应式数据：以下面的函数为例，当 obj.text 的值发生变化时，副作用函数 effect 重新执行，而响应式就是在值变化后能够自动重新执行
```js
const obj ={text:"hello world"}
function effect(){
    //effect 函数的执行会读取 obj.text
    document.body.innerText='Hello world'
}
```

* 响应式数据的基本实现

响应式数据的基本实现就是将副作用函数存储到一个“桶”中

在存储之前我们期望能够拦截一个对象属性的读取和设置操作：

Vue 2：Object.defineProperty
Vue 3：代理对象Proxy

* 设计一个完善的响应系统

响应的系统的工作流程：

当读取操作发生时，将副作用函数收集到”桶“中
当设置操作发生时，将”桶“中取到副作用函数并执行

WeakMap、Map、Set的区别

* 分支切换与cleanup

分支切换可能会产生遗留的副作用函数

* 嵌套的 effect 与 effect 栈

effect 是可以发生嵌套的，Vue.js 的渲染就是哦在一个 effect 中执行的

* 避免无限递归循环---导致栈溢出

在 trigger 动作发生时增加守卫条件，如果 trigger 触发执行的副作用函数与当前正在执行的副作用函数相同，则不触发执行

* 调度执行

可调度性是响应系统非常重要的特性

可调度性：当 trigger 动作触发副作用函数重新执行时，有能力决定副作用函数执行的时机，次数以及公式

* 计算属性 computed与 lazy

* watch 实现原理

watch：本质就是观测一个响应式数据，当响应式数据发生变化时通知并执行响应的回调函数。当然除了观测响应式数据，还可以接收 getter 函数，在 getter 中可以指定 watch 依赖哪些响应式数据，只有这些数据变化时，才会触发回调函数

* 立即执行的 watch 与回调执行时机

watch 本质是对 effect 的二次封装

watch 两个特性：

1.立即执行的回调函数
    默认情况下，watch 回调只会在响应式数据发生变化时才执行。
    通过选项参数 immediate 来指定回调是否需要解立即执行。
    当然，watch 也能指定其他参数来指定回调是否需要立即执行---flush选项来指定调度函数的执行时机。
    在第一次执行的时候没有旧值，oldValue 为 undefined。
2.watch的回调执行在响应式数据变化时才执行

* 过期的副作用---竞态问题

watch函数的回调函数接收第三个参数 onInvalidate

可以使用该函数注册一个回调，这个回调会在当前副作用函数过期时执行

原理：在 watch 内部每次检测到变更后，在副作用函数重新执行之前，会先调用执行通过 onInvalidate 函数注册的过期回调

### 第五章 非原始值的响应式方案

* 理解 Proxy 和 Reflect

Proxy：使用 Proxy 可以创建一个代理对象，能够实现对其他对象的代理。也就是说只能代理对象，无法代理非对象值

代理：对一个对象基本语义的代理

### 第六章 原始值的响应式方案

## 渲染器
